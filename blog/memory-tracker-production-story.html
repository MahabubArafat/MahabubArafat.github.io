<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The story of how a custom memory profiling package solved a company-wide production mystery that had everyone stumped. From heap crashes to the root cause.">
    <meta name="keywords" content="Node.js, Memory Management, NestJS, Production Debugging, Memory Leaks, ShareTrip, NPM Package">
    <meta name="author" content="Mahabub Alam Arafat">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="How I Built a Custom Memory Tracker That Saved Our Production API">
    <meta property="og:description" content="The story of how a custom memory profiling package solved a company-wide production mystery that had everyone stumped. From heap crashes to the root cause.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://mahabubarafat.online/blog/memory-tracker-production-story.html">
    <meta property="og:site_name" content="Mahabub Alam Arafat - Portfolio">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="How I Built a Custom Memory Tracker That Saved Our Production API">
    <meta name="twitter:description" content="The story of how a custom memory profiling package solved a company-wide production mystery that had everyone stumped. From heap crashes to the root cause.">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {{"@context": "https://schema.org","@type": "BlogPosting","headline": "How I Built a Custom Memory Tracker That Saved Our Production API","description": "The story of how a custom memory profiling package solved a company-wide production mystery that had everyone stumped. From heap crashes to the root cause.","author": {{"@type": "Person","name": "Mahabub Alam Arafat"}},"datePublished": "2025-01-16","dateModified": "2025-01-16","publisher": {{"@type": "Person","name": "Mahabub Alam Arafat"}},"mainEntityOfPage": {{"@type": "WebPage","@id": "https://mahabubarafat.online/blog/memory-tracker-production-story.html"}},"keywords": ["Node.js", "Memory Management", "NestJS", "Production Debugging", "Memory Leaks", "ShareTrip", "NPM Package"]}}
    </script>
    
    <title>How I Built a Custom Memory Tracker That Saved Our Production API | Mahabub Alam Arafat</title>
    <link rel="canonical" href="https://mahabubarafat.online/blog/memory-tracker-production-story.html">
    
    <!-- Google AdSense Code -->
    <meta name="google-adsense-account" content="ca-pub-6705222517983610">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6705222517983610"
            crossorigin="anonymous"></script>
    
    <link rel="stylesheet" href="blog_styling.css">
</head>
<body>
    <header>
        <h1>Mahabub Alam Arafat</h1>
        <p>Software Engineer - Blog</p>
    </header>

    <div class="container">
        <a href="../index.html#blog" class="back-link">‚Üê Back to Portfolio</a>
        
        <article>
            <header class="article-header">
                <h1 class="article-title">How I Built a Custom Memory Tracker That Saved Our Production API</h1>
                <div class="article-meta">
                    <div class="meta-item">
                        <span>üìÖ</span>
                        <time datetime="2025-01-16">January 16, 2025</time>
                    </div>
                    <div class="meta-item">
                        <span>‚è±Ô∏è</span>
                        <span>12 min read</span>
                    </div>
                    <div class="meta-item">
                        <span>üè∑Ô∏è</span>
                        <span>Real Story</span>
                    </div>
                </div>
            </header>

            <div class="content">
                
<h1>How I Built a Custom Memory Tracker That Saved Our Production API</h1>

<p><strong>TL;DR:</strong> Our production API kept crashing with "JavaScript heap out of memory" errors. The entire company was hunting for the bug - leads, seniors, DevOps - nobody could find it. So I built a custom memory tracking package that pinpointed the exact function causing the leak. Turns out, a missing <code>bookingCode</code> was returning entire database tables. Here's the whole story.</p>

<h2>The Crisis: When Production Goes Down and Nobody Knows Why</h2>

<p>Picture this: It's a regular Tuesday morning, and suddenly our production API starts throwing <code>JavaScript heap out of memory</code> errors. The app restarts, runs fine for a while, then crashes again. Rinse and repeat.</p>

<p><strong>The Response Team:</strong></p>
<ul>
<li>All team leads: ‚úÖ Mobilized</li>
<li>Senior developers: ‚úÖ On the case</li>
<li>DevOps team: ‚úÖ Investigating</li>
<li>Monitoring dashboards: ‚úÖ Showing nothing useful</li>
<li>Root cause: ‚ùå Nowhere to be found</li>
</ul>

<p>> <strong>The Pressure:</strong> This wasn't just any bug. ShareTrip's booking API was unstable, affecting real customers and real revenue. The clock was ticking.</p>

<h2>The Problem: Memory Leaks Are Invisible Enemies</h2>
<div class="ad-container" style="margin: 30px 0; text-align: center;">
    <ins class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-layout="in-article"
         data-ad-format="fluid"
         data-ad-client="ca-pub-6705222517983610"
         data-ad-slot="1879717900"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>


<p>Memory leaks in Node.js are particularly nasty because:</p>

<ul>
<li><strong>They're silent killers</strong> - No immediate symptoms until it's too late</li>
<li><strong>Traditional monitoring misses them</strong> - CPU and response time look normal</li>
<li><strong>They compound over time</strong> - What starts small becomes catastrophic</li>
<li><strong>Stack traces are useless</strong> - The crash happens far from the actual problem</li>
</ul>

<p>Our existing monitoring showed:</p>
<pre><code># What we could see
‚úÖ API response times: Normal (2-3 seconds)
‚úÖ CPU usage: Healthy (30-40%)
‚úÖ Database connections: Stable
‚ùå Memory usage: "It goes up sometimes" ü§∑‚Äç‚ôÇÔ∏è</code></pre>

<p><strong>The Real Issue:</strong> We had no function-level memory visibility. We knew <em>something</em> was eating memory, but not <em>what</em> or <em>when</em>.</p>

<h2>The Solution: If You Can't Buy It, Build It</h2>

<p>After two days of fruitless debugging, I decided to take a different approach. Instead of guessing, I'd build a tool to <strong>see exactly what was happening</strong>.</p>

<h3>The Requirements</h3>

<p>I needed something that could:</p>
<p>1. <strong>Track memory usage per function</strong> - Not just overall app memory</p>
<p>2. <strong>Work with existing NestJS code</strong> - No major refactoring</p>
<p>3. <strong>Be production-safe</strong> - Toggle on/off without breaking anything</p>
<p>4. <strong>Provide detailed logs</strong> - Function name, memory consumed, execution time</p>
<p>5. <strong>Handle both sync and async functions</strong> - Our API had both</p>

<h3>Building the Memory Profiler</h3>

<p>I created what became the <a href="https://www.npmjs.com/package/@mahabub-arafat/memory-profiler"><code>@mahabub-arafat/memory-profiler</code></a> package. Here's how it works:</p>

<p>#### The Core Concept: Decorators That Measure</p>

<pre><code>import { Injectable } from '@nestjs/common';
import { ProfileAllMethods } from '@mahabub-arafat/memory-profiler';

@Injectable()
@ProfileAllMethods()  // üéØ This is the magic
export class FlightService {
    async getAvailableFlights() {
        // Your existing code - no changes needed
    }

    async getFlightHistory() {
        // This is where the leak was hiding
    }
}</code></pre>

<p>#### What Happens Under the Hood</p>

<p>The decorator wraps each method and:</p>

<p>1. <strong>Captures start memory</strong>: <code>process.memoryUsage().heapUsed</code></p>
<p>2. <strong>Executes the original function</strong></p>
<p>3. <strong>Captures end memory</strong> and calculates difference</p>
<p>4. <strong>Logs everything</strong> with beautiful, color-coded output</p>

<pre><code>// Simplified version of the core logic
function profileMemory(target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
        const startMemory = process.memoryUsage().heapUsed / 1024 / 1024;
        const startTime = Date.now();
        
        const result = await originalMethod.apply(this, args);
        
        const endMemory = process.memoryUsage().heapUsed / 1024 / 1024;
        const executionTime = Date.now() - startTime;
        const memoryConsumed = endMemory - startMemory;
        
        logger.info(`Function: ${propertyName}, Memory: ${memoryConsumed.toFixed(2)}MB, Time: ${executionTime}ms`);
        
        return result;
    };
}</code></pre>

<h2>The Hunt: Deploying the Detective</h2>
<div class="ad-container" style="margin: 30px 0; text-align: center;">
    <ins class="adsbygoogle"
         style="display:block; text-align:center;"
         data-ad-layout="in-article"
         data-ad-format="fluid"
         data-ad-client="ca-pub-6705222517983610"
         data-ad-slot="1879717900"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>


<h3>Setting Up in Production</h3>

<pre><code># Environment setup
ENABLE_MEMORY_PROFILING_DECORATOR=true</code></pre>

<pre><code>// Applied to our suspicious services
@Injectable()
@ProfileAllMethods()
export class FlightService {
    // All methods now being monitored
}

@Injectable()
@ProfileAllMethods() 
export class BookingService {
    // Every function call tracked
}</code></pre>

<h3>The Smoking Gun</h3>

<p>Within hours, the logs revealed the culprit:</p>

<pre><code>INFO [2024-10-23 10:51:53.710 +0600]: Function: getAvailableFlights, Memory: -0.95MB, Time: 2450ms ‚úÖ
INFO [2024-10-23 10:52:15.442 +0600]: Function: createBooking, Memory: 2.3MB, Time: 1200ms ‚úÖ
WARN [2024-10-23 10:52:45.123 +0600]: Function: getFlightHistory, Memory: 847.32MB, Time: 8900ms ‚ö†Ô∏è</code></pre>

<p><strong>There it was.</strong> The <code>getFlightHistory</code> function was consuming <strong>847MB</strong> in a single call. In a normal application, that's astronomical.</p>

<h2>The Root Cause: A Tale of Missing Data</h2>

<h3>The Investigation</h3>

<p>I dove into the <code>getFlightHistory</code> function:</p>

<pre><code>async getFlightHistory(providerId: string, bookingCode?: string) {
    const filter: any = { providerId };
    
    // The bug was here ‚¨áÔ∏è
    if (bookingCode) {
        filter.bookingCode = bookingCode;
    }
    
    // This query was the problem
    return await this.flightHistoryRepository.find(filter);
}</code></pre>

<h3>The Eureka Moment</h3>

<p>For one specific provider, the third-party API wasn't sending <code>bookingCode</code> in their responses. So our filter became:</p>

<pre><code>// What we expected
filter = { providerId: "PROVIDER_123", bookingCode: "ABC123" }

// What actually happened
filter = { providerId: "PROVIDER_123" }  // bookingCode was undefined</code></pre>

<p><strong>The Result:</strong> Instead of returning one specific flight record, we were returning <strong>the entire flight history table</strong> for that provider. Thousands of records. Hundreds of megabytes. Every. Single. Time.</p>

<h3>The Cascade Effect</h3>

<pre><code># What happened in production
User requests flight history ‚Üí Missing bookingCode ‚Üí Return entire table ‚Üí 
Memory spike ‚Üí Multiply by concurrent users ‚Üí Heap overflow ‚Üí App crash</code></pre>

<h2>The Fix: Simple but Critical</h2>

<pre><code>async getFlightHistory(providerId: string, bookingCode?: string) {
    const filter: any = { providerId };
    
    // The fix ‚úÖ
    if (!bookingCode) {
        throw new BadRequestException('Booking code is required');
    }
    
    filter.bookingCode = bookingCode;
    return await this.flightHistoryRepository.find(filter);
}</code></pre>

<p><strong>Result:</strong> Memory usage dropped from 847MB to 2.3MB per call. Problem solved.</p>

<h2>The Impact: More Than Just a Bug Fix</h2>

<h3>Immediate Results</h3>
<ul>
<li><strong>üöÄ Zero crashes</strong> after the fix</li>
<li><strong>üí∞ Revenue protection</strong> - No more booking interruptions</li>
<li><strong>üòå Team relief</strong> - The mystery was finally solved</li>
<li><strong>üìä Memory visibility</strong> - We could now see what we couldn't before</li>
</ul>

<h3>Long-term Benefits</h3>
<ul>
<li><strong>Published the package</strong> on <a href="https://www.npmjs.com/package/@mahabub-arafat/memory-profiler">NPM</a> for the community</li>
<li><strong>Proactive monitoring</strong> - We now profile new services by default</li>
<li><strong>Faster debugging</strong> - Similar issues get caught in hours, not days</li>
<li><strong>Team confidence</strong> - We have the tools to solve production mysteries</li>
</ul>

<h2>The Package: Built for Real-World Use</h2>

<h3>Key Features</h3>

<pre><code>// Profile everything in a class
@ProfileAllMethods()
export class SomeService { }

// Profile individual functions
@ProfileMemoryAsyncFunction()
async specificMethod() { }

@ProfileMemorySyncFunction()
syncMethod() { }</code></pre>

<h3>Production-Safe Design</h3>

<ul>
<li><strong>Environment toggle</strong>: Only runs when <code>ENABLE_MEMORY_PROFILING_DECORATOR=true</code></li>
<li><strong>Zero performance impact</strong> when disabled</li>
<li><strong>Beautiful logging</strong> with <code>pino</code> and color coding</li>
<li><strong>TypeScript support</strong> out of the box</li>
</ul>

<h3>Real Output in Action</h3>

<pre><code>INFO [2024-10-23 10:51:53.710 +0600] (776639 on st): 
  Async -> Function: getAvailableFlights, 
  startMemory: 45.57MB, endMemory: 44.62MB, 
  memoryConsumed: -0.95MB, executionTime: 2450 ms

WARN [2024-10-23 10:52:21.261 +0600] (776639 on st): 
  Async -> Function: timedoutSearch, 
  startMemory: 42.17MB, endMemory: 36.15MB, 
  memoryConsumed: -6.02MB, executionTime: 30000 ms</code></pre>

<h2>Lessons Learned: The Real Takeaways</h2>

<h3>1. Build the Tools You Need</h3>
<p>Sometimes the solution isn't in existing tools. When you can't find what you need, build it. The time invested in creating the right tool pays dividends.</p>

<h3>2. Function-Level Monitoring Matters</h3>
<p>Application-level metrics miss the details. Function-level visibility reveals the real culprits hiding in your codebase.</p>

<h3>3. Memory Leaks Are Sneaky</h3>
<p>They don't always look like traditional leaks. Sometimes it's just one function doing too much work, too often.</p>

<h3>4. Production Debugging Requires Production Tools</h3>
<p>Development tools often can't replicate production scenarios. Build tools that work safely in production.</p>

<h3>5. Share Your Solutions</h3>
<p>Publishing the package helped other developers facing similar issues. Open source makes everyone stronger.</p>

<h2>What's Next: The Future of Memory Monitoring</h2>

<p>I'm working on v2 of the memory profiler with:</p>
<ul>
<li><strong>Heap dump integration</strong> for deeper analysis</li>
<li><strong>Memory trend tracking</strong> over time</li>
<li><strong>Automatic alerting</strong> for memory spikes</li>
<li><strong>Integration with APM tools</strong> like New Relic and DataDog</li>
</ul>

<h2>Try It Yourself</h2>

<p>Want to add function-level memory monitoring to your NestJS app?</p>

<pre><code>npm install @mahabub-arafat/memory-profiler</code></pre>

<p>Check out the full documentation on <a href="https://github.com/mahabubarafat-st/memory-profiler">GitHub</a> and <a href="https://www.npmjs.com/package/@mahabub-arafat/memory-profiler">NPM</a>.</p>

<hr>

<p><strong>The Bottom Line:</strong> Sometimes the best debugging tool is the one you build yourself. When production is on fire and traditional tools aren't helping, don't be afraid to create something new. You might just save the day - and help other developers in the process.</p>

<p><em>Have you ever built custom debugging tools to solve production issues? I'd love to hear your stories. Connect with me on <a href="https://linkedin.com/in/mahabubarafat">LinkedIn</a> - let's share war stories and solutions.</em></p>

            </div>

            <!-- End of Article Ad -->
            <div class="ad-container" style="margin: 40px 0; text-align: center;">
                <ins class="adsbygoogle"
                     style="display:block; text-align:center;"
                     data-ad-layout="in-article"
                     data-ad-format="fluid"
                     data-ad-client="ca-pub-6705222517983610"
                     data-ad-slot="1879717900"></ins>
                <script>
                     (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>

            <div class="social-share">
                <h3>Share this article</h3>
                <div class="share-buttons">
                    <a href="https://linkedin.com/shareArticle?mini=true&url=https://mahabubarafat.online/blog/memory-tracker-production-story.html&title=How I Built a Custom Memory Tracker That Saved Our Production API" target="_blank" class="share-btn share-linkedin">Share on LinkedIn</a>
                    <a href="https://twitter.com/intent/tweet?url=https://mahabubarafat.online/blog/memory-tracker-production-story.html&text=How I Built a Custom Memory Tracker That Saved Our Production API" target="_blank" class="share-btn share-twitter">Share on Twitter</a>
                </div>
            </div>

            <div class="author-bio">
                <h3>About the Author</h3>
                <p><strong>Mahabub Alam Arafat</strong> is a Software Engineer at ShareTrip with 2+ years of production experience. He specializes in backend development, API optimization, and turning legacy systems into modern, maintainable code.</p>
                <p><a href="../index.html#contact">Get in touch</a> | <a href="https://linkedin.com/in/mahabubarafat" target="_blank">LinkedIn</a> | <a href="https://github.com/MahabubArafat" target="_blank">GitHub</a></p>
            </div>
        </article>
    </div>

    <footer>
        <p>¬© 2025 Mahabub Alam Arafat. All rights reserved.</p>
    </footer>
</body>
</html>